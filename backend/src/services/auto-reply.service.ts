import { User } from "../models/User";
import { IMailRepository } from "../interfaces/repositories/IMailRepository";
import { IAIService } from "../interfaces/services/IAIService";
import { IAutoReplyRepository } from "../interfaces/repositories/IAutoReplyRepository";
import { IAutoReplyService, IAutoReplySettings, IAutoReplyUpdateInput } from "../interfaces/services/IAutoReplyService";
import { GmailVendor, IGmailInboundMessage } from "../vendors/GmailVendor";
import { IAutoReplyIntentTag } from "../interfaces/services/IAIService";

export class AutoReplyService implements IAutoReplyService {
    constructor(
        private readonly autoReplyRepository: IAutoReplyRepository,
        private readonly mailRepository: IMailRepository,
        private readonly aiService: IAIService,
        private readonly gmailVendor: GmailVendor
    ) {}

    async getSettings(userId: string): Promise<IAutoReplySettings> {
        const user = await User.findById(userId).lean();
        if (!user) throw new Error("User not found");
        return {
            autoReplyEnabled: !!user.autoReplyEnabled,
            autoReplyMode: user.autoReplyMode === "auto" ? "auto" : "manual",
            autoReplySignature: user.autoReplySignature || "",
            autoReplyCooldownMinutes: Number(user.autoReplyCooldownMinutes || 120),
            gmailLastProcessedAt: user.gmailLastProcessedAt,
        };
    }

    async updateSettings(userId: string, input: IAutoReplyUpdateInput): Promise<IAutoReplySettings> {
        const updates: Record<string, unknown> = {};
        if (typeof input.autoReplyEnabled === "boolean") updates.autoReplyEnabled = input.autoReplyEnabled;
        if (input.autoReplyMode === "manual" || input.autoReplyMode === "auto") updates.autoReplyMode = input.autoReplyMode;
        if (typeof input.autoReplySignature === "string") updates.autoReplySignature = input.autoReplySignature.slice(0, 500);
        if (typeof input.autoReplyCooldownMinutes === "number") {
            updates.autoReplyCooldownMinutes = Math.min(7 * 24 * 60, Math.max(10, Math.floor(input.autoReplyCooldownMinutes)));
        }

        const updated = await User.findByIdAndUpdate(userId, updates, { new: true }).lean();
        if (!updated) throw new Error("User not found");
        return {
            autoReplyEnabled: !!updated.autoReplyEnabled,
            autoReplyMode: updated.autoReplyMode === "auto" ? "auto" : "manual",
            autoReplySignature: updated.autoReplySignature || "",
            autoReplyCooldownMinutes: Number(updated.autoReplyCooldownMinutes || 120),
            gmailLastProcessedAt: updated.gmailLastProcessedAt,
        };
    }

    async listInbound(userId: string, limit = 50) {
        return this.autoReplyRepository.findInboundForReview(userId, limit);
    }

    async getMailDetails(userId: string, mailId: string) {
        const inbound = await this.autoReplyRepository.findById(mailId);
        if (!inbound || inbound.userId !== userId || inbound.direction !== "INBOUND") {
            throw new Error("Inbound mail not found");
        }
        const autoReply = await this.autoReplyRepository.findLatestAutoReplyForInbound(
            userId,
            inbound.providerMessageId,
            inbound.providerThreadId
        );
        return { inbound, autoReply };
    }

    async approveDraft(userId: string, mailId: string): Promise<void> {
        const inbound = await this.autoReplyRepository.findById(mailId);
        if (!inbound || inbound.userId !== userId || inbound.direction !== "INBOUND") {
            throw new Error("Inbound mail not found");
        }
        const user = await User.findById(userId).lean();
        if (!user?.refreshToken || !user?.email) throw new Error("Google token not found");

        const toEmail = this.extractEmail(inbound.from);
        if (!toEmail || !inbound.providerThreadId) throw new Error("Invalid inbound message metadata");

        const generated = await this.aiService.generateAutoReply({
            subject: inbound.subject,
            body: inbound.content,
            sender: inbound.from,
            tone: this.intentToTone(inbound.intentTag || "Inquiry"),
            policy: `${this.intentToPolicy(inbound.intentTag || "Inquiry")} This is a manually approved reply.`,
        });
        const withSignature = this.appendSignature(generated, user.autoReplySignature || "");

        const outbound = await this.autoReplyRepository.create({
            userId,
            from: user.email,
            to: toEmail,
            subject: inbound.subject.startsWith("Re:") ? inbound.subject : `Re: ${inbound.subject}`,
            content: withSignature,
            status: "PENDING",
            direction: "OUTBOUND",
            providerThreadId: inbound.providerThreadId,
            inReplyTo: inbound.providerMessageId,
            isAutoGenerated: true,
            autoReplyStatus: "DRAFTED",
            createdAt: new Date(),
        });

        const ok = await this.gmailVendor.sendReplyInThread({
            refreshToken: user.refreshToken,
            from: user.email,
            to: toEmail,
            subject: outbound.subject,
            html: withSignature,
            threadId: inbound.providerThreadId,
            inReplyTo: inbound.providerMessageId,
        });

        if (!ok || !outbound.id) {
            throw new Error("Failed to send approval reply");
        }
        await this.mailRepository.updateStatus(outbound.id, "SENT");
        await this.autoReplyRepository.markAutoReplied(mailId);
    }

    async rejectDraft(userId: string, mailId: string, reason?: string): Promise<void> {
        const inbound = await this.autoReplyRepository.findById(mailId);
        if (!inbound || inbound.userId !== userId || inbound.direction !== "INBOUND") {
            throw new Error("Inbound mail not found");
        }
        if (!inbound.id) return;
        await this.autoReplyRepository.updateAutoReplyResult(inbound.id, "BLOCKED", reason || "Rejected by user");
    }

    async runForUser(userId: string): Promise<{ processed: number }> {
        const user = await User.findById(userId);
        if (!user || !user.autoReplyEnabled || !user.refreshToken || !user.email) {
            return { processed: 0 };
        }

        const after = user.gmailLastProcessedAt || new Date(Date.now() - 24 * 60 * 60 * 1000);
        const messages = await this.gmailVendor.listRecentInboxMessages(user.refreshToken, after, 20);
        if (messages.length === 0) {
            user.gmailLastProcessedAt = new Date();
            await user.save();
            return { processed: 0 };
        }

        let processed = 0;
        for (const message of messages) {
            const handled = await this.processSingleInbound(userId, user.email, user.refreshToken, user.autoReplyMode || "manual", Number(user.autoReplyCooldownMinutes || 120), user.autoReplySignature || "", message);
            if (handled) processed += 1;
        }

        user.gmailLastProcessedAt = new Date();
        await user.save();
        return { processed };
    }

    async runForEnabledUsers(): Promise<void> {
        const users = await User.find({ autoReplyEnabled: true, refreshToken: { $exists: true, $ne: "" } })
            .select("_id")
            .lean();
        for (const user of users) {
            try {
                await this.runForUser(String(user._id));
            } catch (error) {
                console.error("Auto-reply loop failed for user:", user._id, error);
            }
        }
    }

    private async processSingleInbound(
        userId: string,
        userEmail: string,
        refreshToken: string,
        mode: "manual" | "auto",
        cooldownMinutes: number,
        signature: string,
        message: IGmailInboundMessage
    ): Promise<boolean> {
        const existing = await this.autoReplyRepository.findByProviderMessageId(message.id, userId);
        if (existing) return false;

        const intentResult = await this.aiService.classifyAutoReplyIntent(message.subject || "", message.body || "", message.from);

        const inbound = await this.autoReplyRepository.create({
            userId,
            from: message.from,
            to: message.to,
            subject: message.subject || "(No Subject)",
            content: message.body || "",
            status: "SENT",
            direction: "INBOUND",
            providerMessageId: message.id,
            providerThreadId: message.threadId,
            inReplyTo: message.inReplyTo,
            intentTag: intentResult.intent,
            intentConfidence: intentResult.confidence,
            createdAt: new Date(message.date || Date.now()),
        });

        if (!inbound.id) return false;

        const safetyReason = await this.getSafetyBlockReason(userId, userEmail, cooldownMinutes, message);
        if (safetyReason) {
            await this.autoReplyRepository.updateAutoReplyResult(inbound.id, "BLOCKED", safetyReason);
            return true;
        }

        if (intentResult.intent === "Spam-like") {
            await this.autoReplyRepository.updateAutoReplyResult(inbound.id, "BLOCKED", `Intent blocked: Spam-like (${intentResult.reason || "AI classified as spam-like"})`);
            return true;
        }

        const toEmail = this.extractEmail(message.from);
        if (!toEmail) {
            await this.autoReplyRepository.updateAutoReplyResult(inbound.id, "SKIPPED", "Sender email not found");
            return true;
        }

        const replyHtml = this.appendSignature(
            await this.aiService.generateAutoReply({
                subject: message.subject,
                body: message.body,
                sender: message.from,
                tone: this.intentToTone(intentResult.intent),
                policy: this.intentToPolicy(intentResult.intent),
            }),
            signature
        );

        const outbound = await this.autoReplyRepository.create({
            userId,
            from: userEmail,
            to: toEmail,
            subject: message.subject?.startsWith("Re:") ? message.subject : `Re: ${message.subject || "(No Subject)"}`,
            content: replyHtml,
            status: "PENDING",
            direction: "OUTBOUND",
            providerThreadId: message.threadId,
            inReplyTo: message.id,
            isAutoGenerated: true,
            autoReplyStatus: "DRAFTED",
            createdAt: new Date(),
        });

        if (mode === "manual") {
            await this.autoReplyRepository.updateAutoReplyResult(
                inbound.id,
                "DRAFTED",
                `Awaiting manual approval (${intentResult.intent}, ${Math.round(intentResult.confidence * 100)}%)`
            );
            return true;
        }

        const ok = await this.gmailVendor.sendReplyInThread({
            refreshToken,
            from: userEmail,
            to: toEmail,
            subject: outbound.subject,
            html: replyHtml,
            threadId: message.threadId,
            inReplyTo: message.id,
        });

        if (ok && outbound.id) {
            await this.mailRepository.updateStatus(outbound.id, "SENT");
            await this.autoReplyRepository.markAutoReplied(inbound.id);
        } else if (outbound.id) {
            await this.mailRepository.updateStatus(outbound.id, "FAILED");
            await this.autoReplyRepository.updateAutoReplyResult(inbound.id, "BLOCKED", "Send failed");
        }
        return true;
    }

    private async getSafetyBlockReason(
        userId: string,
        userEmail: string,
        cooldownMinutes: number,
        message: IGmailInboundMessage
    ): Promise<string | null> {
        const fromEmail = this.extractEmail(message.from).toLowerCase();
        if (!fromEmail) return "Sender address missing";
        if (fromEmail === userEmail.toLowerCase()) return "Own email detected";
        if (fromEmail.includes("no-reply") || fromEmail.includes("noreply")) return "No-reply sender";
        if ((message.autoSubmitted || "").toLowerCase().includes("auto")) return "Auto-submitted header";
        if ((message.precedence || "").toLowerCase().includes("bulk")) return "Bulk precedence header";
        if (message.listId) return "List mail detected";

        const since = new Date(Date.now() - cooldownMinutes * 60 * 1000);
        const recent = await this.autoReplyRepository.findRecentAutoReplyByThread(userId, message.threadId, since);
        if (recent) return `Cooldown active (${cooldownMinutes}m)`;
        return null;
    }

    private extractEmail(value: string): string {
        if (!value) return "";
        const match = value.match(/<([^>]+)>/) || value.match(/([A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,})/i);
        return (match?.[1] || match?.[0] || "").trim();
    }

    private appendSignature(html: string, signature: string): string {
        const cleanSig = signature.trim();
        if (!cleanSig) return html;
        const safeSig = cleanSig.replace(/\n/g, "<br/>");
        return `${html}<p><br/>${safeSig}</p>`;
    }

    private intentToTone(intent: IAutoReplyIntentTag): string {
        if (intent === "Complaint") return "Calm, empathetic, solution-focused";
        if (intent === "Follow-up") return "Professional and proactive";
        if (intent === "Inquiry") return "Helpful and concise";
        return "Neutral and careful";
    }

    private intentToPolicy(intent: IAutoReplyIntentTag): string {
        if (intent === "Complaint") {
            return "Acknowledge concern, apologize briefly, avoid blame, propose next step. Do not admit legal liability.";
        }
        if (intent === "Follow-up") {
            return "Acknowledge prior context and give a clear update or request one missing detail.";
        }
        if (intent === "Inquiry") {
            return "Provide a clear direct answer. If unclear, ask one short clarification question.";
        }
        return "Do not engage in promotional/spam-like content.";
    }
}
